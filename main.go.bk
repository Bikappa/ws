package main

import (
	"bufio"
	"crypto/sha1"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"net"
	"strings"
	"time"
)

type Frame struct {
	Fin     bool
	Rsvs    []bool
	Opcode  byte
	Payload []byte
}

const (
	WS_OPCODE_CONTINUATION byte = 0x0
	WS_OPCODE_PING         byte = 0x9
	WS_OPCODE_PONG         byte = 0xa
	WS_OPCODE_TEXT         byte = 0x1
	WS_OPCODE_BINARY       byte = 0x2
)

func pingFrame() []byte {
	frame := []byte{0x89, 0x00}
	fmt.Println(hex.Dump(frame))
	return frame
}

func createMessageFrame(r io.Reader, payloadLength uint64, binary bool) []byte {
	opCode := WS_OPCODE_TEXT
	if binary {
		opCode = WS_OPCODE_BINARY
	}
	header := []byte{
		0x80 | opCode,
	}
	var payloadLengthBytes int
	if payloadLength <= 125 {
		header = append(header, uint8(payloadLength))
	} else {
		if payloadLength <= uint64(0xffff) {
			header = append(header, uint8(126))
			payloadLengthBytes = 2
		} else {
			header = append(header, uint8(127))
			payloadLengthBytes = 8
		}

		for i := payloadLengthBytes - 1; i >= 0; i-- {
			header = append(header, uint8(payloadLength>>i*8))
		}
	}

	payload := make([]byte, payloadLength)
	r.Read(payload)

	frame := make([]byte, len(header)+int(payloadLength))
	copy(frame, header)

	payloadSlice := frame[len(header):]
	copy(payloadSlice, payload)

	return frame
}

func createTextFrame(text string) []byte {
	r := strings.NewReader(text)
	return createMessageFrame(r, uint64(len(text)), false)
}

func main() {
	ln, err := net.Listen("tcp", "localhost:8080")
	if err != nil {
		panic(err)
	}
	for {
		fmt.Println(
			`Ready to accept connections
Port: 8080`)
		conn, err := ln.Accept()
		fmt.Printf("Connection from %s\n", conn.RemoteAddr().String())

		if err != nil {
			fmt.Println(err)
			break
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	scanner := bufio.NewScanner(conn)

	// Read status line
	scanner.Scan()
	requestLine := strings.Split(scanner.Text(), " ")
	method := requestLine[0]
	path := requestLine[1]
	protocol := requestLine[2]

	fmt.Printf("Method: %s, path: %s, protocol: %s\n", method, path, protocol)

	headers := map[string]string{}

	for {
		scanner.Scan()
		line := scanner.Text()
		if line == "" {
			break
		}

		headerParts := strings.Split(line, ": ")
		headers[headerParts[0]] = headerParts[1]
	}

	if value, ok := headers["Connection"]; !ok || value != "Upgrade" {
		fmt.Println("Connection header invalid")
		conn.Close()
	}

	if value, ok := headers["Upgrade"]; !ok || value != "websocket" {
		fmt.Println("Unrecognized upgrade", value)
		conn.Close()
	}

	handleWebsocket(conn, headers)
}

func handleWebsocket(conn net.Conn, headers map[string]string) {
	for key, val := range headers {
		fmt.Printf("%s: %s\n", key, val)
	}
	fmt.Println()

	readWriter := conn

	accept := generateWebsocketAccept(headers["Sec-WebSocket-Key"])
	responseMessage := fmt.Sprintf(
		`HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: %s

`, accept)

	fmt.Println(responseMessage)
	if _, err := readWriter.Write([]byte(responseMessage)); err != nil {
		fmt.Println(err.Error())
		return
	}

	// if n, err := readWriter.Write(pingFrame()); err != nil {
	// 	fmt.Println(err)
	// 	return
	// } else {
	// 	fmt.Println("sent ping", n, "bytes")
	// }

	// readWriter.Flush()

	// fmt.Println("waiting for client frame")
	// frameStart := make([]byte, 2)
	// _, err := readWriter.Read(frameStart)

	// if err != nil {
	// 	fmt.Println(err)
	// 	return
	// }
	// fmt.Println(hex.Dump(frameStart))
	// maskKey := make([]byte, 4)
	// readWriter.Read(maskKey)
	// fmt.Println(hex.Dump(maskKey))
	close := make(chan int)
	go listenMessages(conn, MessageHandlers{
		OnText: func(text string) {
			fmt.Println("Received text:", text)
		},
		OnData: func(data []byte) {
			fmt.Println("Received data:", data)
		},
	}, close)
	go startCounting(conn, close)

	<-close
}

func generateWebsocketAccept(key string) string {
	suffixString := "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
	concatenation := fmt.Sprintf("%s%s", key, suffixString)

	h := sha1.New()
	fmt.Fprint(h, concatenation)
	sha := h.Sum(nil)
	return base64.StdEncoding.EncodeToString(sha)
}

func readFrame(r io.Reader) (*Frame, error) {
	frameStart := make([]byte, 2)
	if _, err := r.Read(frameStart); err != nil {
		fmt.Println(err)
		return nil, errors.New("Invalid frame")
	} else {
		flags := frameStart[0]
		fin := flags&0x80 != 0
		rsv1 := flags&0x40 != 0
		rsv2 := flags&0x20 != 0
		rsv3 := flags&0x10 != 0
		opcode := flags & 0x0f

		secondByte := frameStart[1]
		mask := secondByte&0x80 != 0
		if !mask {
			return nil, errors.New("Unmasked frame")
		}

		payloadLength := resolvePayloadLength(r, secondByte&0x7f)

		maskingKey := make([]byte, 4)
		r.Read(maskingKey)

		payloadData := make([]byte, payloadLength)
		r.Read(payloadData)
		unmasked := unmaskData(payloadData, maskingKey)

		return &Frame{
			Fin:     fin,
			Rsvs:    []bool{rsv1, rsv2, rsv3},
			Opcode:  opcode,
			Payload: unmasked,
		}, nil
	}
}

func resolvePayloadLength(r io.Reader, firstLengthByte byte) uint64 {
	if firstLengthByte <= 125 {
		return uint64(firstLengthByte)
	}
	nBytes := 2
	if firstLengthByte == 127 {
		nBytes = 8
	}

	payloadLength := uint64(0)
	lengthBytes := make([]byte, nBytes)
	r.Read(lengthBytes)
	for i := nBytes - 1; i >= 0; i-- {
		b := lengthBytes[nBytes-1-i]
		payloadLength = payloadLength & (uint64(b) << i * 8)
	}
	return payloadLength
}

func unmaskData(data []byte, mask []byte) []byte {
	unmasked := make([]byte, len(data))
	for i, b := range data {
		unmasked[i] = b ^ mask[i%4]
	}
	return unmasked
}

type MessageHandlers struct {
	OnText func(text string)
	OnData func(data []byte)
}

func listenMessages(r io.Reader, mhs MessageHandlers, closeCh chan int) error {
	for {
		if frame, err := readFrame(r); err != nil {
			fmt.Println(err.Error())
			closeCh <- 1
			return err
		} else {
			switch frame.Opcode {
			case WS_OPCODE_TEXT:
				mhs.OnText(string(frame.Payload))
				break
			case WS_OPCODE_BINARY:
				mhs.OnData(frame.Payload)
				break
			}
		}
	}
}

func startCounting(w io.Writer, closeCh chan int) error {
	count := uint(0)

	for {
		frame := createTextFrame(fmt.Sprintf("Count: %d", count))
		fmt.Println("Sending:", fmt.Sprintf("Count: %d", count))
		_, err := w.Write(frame)
		if err != nil {
			closeCh <- 1
			return err
		}
		time.Sleep(time.Second)
		count++
	}
}
